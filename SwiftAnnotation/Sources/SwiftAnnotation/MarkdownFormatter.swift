import Foundation

/// Formats element information and feedback into markdown for AI agents
public struct MarkdownFormatter {

    public init() {}

    /// Format a single annotation with element info and feedback
    /// - Parameters:
    ///   - element: The element information
    ///   - feedback: The user's feedback text
    /// - Returns: Formatted markdown string
    public func format(element: ElementInfo, feedback: String) -> String {
        var lines: [String] = []

        lines.append("## UI Annotation")
        lines.append("")
        lines.append("**Element:** \(element.typeName)")
        lines.append("**Hierarchy:** \(element.hierarchyPath)")

        if let accessibilityId = element.accessibilityIdentifier, !accessibilityId.isEmpty {
            lines.append("**Accessibility ID:** `\(accessibilityId)`")
        }

        if let accessibilityLabel = element.accessibilityLabel, !accessibilityLabel.isEmpty {
            lines.append("**Accessibility Label:** \"\(accessibilityLabel)\"")
        }

        if let accessibilityHint = element.accessibilityHint, !accessibilityHint.isEmpty {
            lines.append("**Accessibility Hint:** \"\(accessibilityHint)\"")
        }

        lines.append("**Frame:** \(element.frameString)")

        if !feedback.isEmpty {
            lines.append("")
            lines.append("### Feedback")
            lines.append(feedback)
        }

        lines.append("")

        return lines.joined(separator: "\n")
    }

    /// Format multiple annotations into a single markdown document
    /// - Parameter annotations: Array of (element, feedback) tuples
    /// - Returns: Formatted markdown string
    public func formatMultiple(annotations: [(element: ElementInfo, feedback: String)]) -> String {
        var lines: [String] = []

        lines.append("# UI Annotations")
        lines.append("")
        lines.append("Generated by SwiftAnnotation")
        lines.append("")
        lines.append("---")
        lines.append("")

        for (index, annotation) in annotations.enumerated() {
            if index > 0 {
                lines.append("---")
                lines.append("")
            }

            lines.append(format(element: annotation.element, feedback: annotation.feedback))
        }

        return lines.joined(separator: "\n")
    }

    /// Format element info only (without feedback) for quick inspection
    /// - Parameter element: The element information
    /// - Returns: Compact markdown string
    public func formatCompact(element: ElementInfo) -> String {
        var parts: [String] = []

        parts.append("**\(element.typeName)**")

        if let accessibilityId = element.accessibilityIdentifier, !accessibilityId.isEmpty {
            parts.append("id=`\(accessibilityId)`")
        }

        parts.append("at \(element.frameString)")

        return parts.joined(separator: " ")
    }

    /// Format for clipboard - includes context helpful for AI agents
    public func formatForClipboard(element: ElementInfo, feedback: String, appName: String? = nil) -> String {
        var lines: [String] = []

        lines.append("## UI Annotation")

        if let app = appName {
            lines.append("**App:** \(app)")
        }

        lines.append("**Element:** \(element.typeName)")
        lines.append("**Hierarchy:** `\(element.hierarchyPath)`")

        if let accessibilityId = element.accessibilityIdentifier, !accessibilityId.isEmpty {
            lines.append("**Accessibility ID:** `\(accessibilityId)`")
        }

        if let accessibilityLabel = element.accessibilityLabel, !accessibilityLabel.isEmpty {
            lines.append("**Accessibility Label:** \"\(accessibilityLabel)\"")
        }

        lines.append("**Frame:** \(element.frameString)")
        lines.append("**Depth:** \(element.depth) levels from root")

        if !feedback.isEmpty {
            lines.append("")
            lines.append("### Feedback")
            lines.append(feedback)
        }

        lines.append("")
        lines.append("---")
        lines.append("*Use this selector path to locate the component in the SwiftUI codebase.*")

        return lines.joined(separator: "\n")
    }
}
